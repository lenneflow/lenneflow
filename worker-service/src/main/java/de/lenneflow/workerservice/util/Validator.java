package de.lenneflow.workerservice.util;

import de.lenneflow.workerservice.dto.LocalClusterDTO;
import de.lenneflow.workerservice.dto.ManagedClusterDTO;
import de.lenneflow.workerservice.dto.NodeGroupDTO;
import de.lenneflow.workerservice.dto.UnmanagedClusterDTO;
import de.lenneflow.workerservice.enums.CloudProvider;
import de.lenneflow.workerservice.exception.InternalServiceException;
import de.lenneflow.workerservice.exception.PayloadNotValidException;
import de.lenneflow.workerservice.model.AccessToken;
import de.lenneflow.workerservice.model.CloudCredential;
import de.lenneflow.workerservice.model.KubernetesCluster;
import de.lenneflow.workerservice.repository.AccessTokenRepository;
import de.lenneflow.workerservice.repository.CloudCredentialRepository;
import de.lenneflow.workerservice.repository.KubernetesClusterRepository;
import org.springframework.stereotype.Component;

@Component
public class Validator {

    final KubernetesClusterRepository kubernetesClusterRepository;
    final AccessTokenRepository accessTokenRepository;
    final CloudCredentialRepository cloudCredentialRepository;


    public Validator(KubernetesClusterRepository kubernetesClusterRepository, AccessTokenRepository accessTokenRepository, CloudCredentialRepository cloudCredentialRepository) {
        this.kubernetesClusterRepository = kubernetesClusterRepository;
        this.accessTokenRepository = accessTokenRepository;
        this.cloudCredentialRepository = cloudCredentialRepository;
    }


    public void validate(KubernetesCluster kubernetesCluster, boolean isUpdate) {
        if (kubernetesCluster.getUid() == null || kubernetesCluster.getUid().isEmpty()) {
            throw new InternalServiceException("Uuid was not generated by the system");
        }
        KubernetesCluster cluster = kubernetesClusterRepository.findByClusterNameAndCloudProviderAndRegion(kubernetesCluster.getClusterName(), kubernetesCluster.getCloudProvider(), kubernetesCluster.getRegion());
        if (!isUpdate && cluster != null) {
            String message = "The cluster \"" + cluster.getClusterName() + "\" in the region \"" + kubernetesCluster.getRegion() + "\" already exists in " + kubernetesCluster.getCloudProvider().toString() + " cloud!";
            throw new PayloadNotValidException(message);
        }
    }

    public void validate(NodeGroupDTO nodeGroupDTO) {
        if (nodeGroupDTO.getDesiredNodeCount() < 1) {
            throw new PayloadNotValidException("DesiredNodeCount is required");
        }
        if (nodeGroupDTO.getMinimumNodeCount() < 1) {
            throw new PayloadNotValidException("MinimumNodeCount is required");
        }
        if(nodeGroupDTO.getDesiredNodeCount() < nodeGroupDTO.getMinimumNodeCount()) {
            throw new PayloadNotValidException("MinimumNodeCount must be less than the DesiredNodeCount " + nodeGroupDTO.getDesiredNodeCount());
        }
        if (nodeGroupDTO.getMaximumNodeCount() < 1) {
            throw new PayloadNotValidException("MaximumNodeCount is required");
        }
        if(nodeGroupDTO.getDesiredNodeCount() > nodeGroupDTO.getMaximumNodeCount()) {
            throw new PayloadNotValidException("MaximumNodeCount must be greater than than the DesiredNodeCount " + nodeGroupDTO.getDesiredNodeCount());
        }
        if(nodeGroupDTO.getClusterUid() == null || nodeGroupDTO.getClusterUid().isEmpty()) {
            throw new PayloadNotValidException("ClusterUid is required");
        }
        KubernetesCluster cluster = kubernetesClusterRepository.findByUid(nodeGroupDTO.getClusterUid());
        if (cluster == null) {
            throw new PayloadNotValidException("Cluster UID is not valid. Please provide a valid cluster UID");
        }
    }

    public void validate(ManagedClusterDTO managedClusterDTO) {

        if (managedClusterDTO.getClusterName() == null || managedClusterDTO.getClusterName().isEmpty()) {
            throw new PayloadNotValidException("KubernetesCluster Name is required");
        }
        if (managedClusterDTO.getRegion() == null || managedClusterDTO.getRegion().isEmpty()) {
            throw new PayloadNotValidException("Region is required");
        }
        if (managedClusterDTO.getKubernetesVersion() == null || managedClusterDTO.getKubernetesVersion().isEmpty()) {
            throw new PayloadNotValidException("KubernetesVersion is required");
        }
        if (managedClusterDTO.getCloudProvider() == null || managedClusterDTO.getCloudProvider().toString().isEmpty()) {
            throw new PayloadNotValidException("CloudProvider is required");
        }
        if (managedClusterDTO.getDesiredNodeCount() < 1) {
            throw new PayloadNotValidException("DesiredNodeCount is required");
        }
        if (managedClusterDTO.getMinimumNodeCount() < 1) {
            throw new PayloadNotValidException("MinimumNodeCount is required");
        }
        if(managedClusterDTO.getDesiredNodeCount() < managedClusterDTO.getMinimumNodeCount()) {
            throw new PayloadNotValidException("DesiredNodeCount must not be less than minimumNodeCount");
        }
        if (managedClusterDTO.getMaximumNodeCount() < 1) {
            throw new PayloadNotValidException("MaximumNodeCount is required");
        }
        if(managedClusterDTO.getDesiredNodeCount() > managedClusterDTO.getMaximumNodeCount()) {
            throw new PayloadNotValidException("DesiredNodeCount must not be greater than MaximumNodeCount");
        }
        if (managedClusterDTO.getInstanceType() == null || managedClusterDTO.getInstanceType().isEmpty()) {
            throw new PayloadNotValidException("InstanceType is required");
        }
        if (managedClusterDTO.getAmiType() == null || managedClusterDTO.getAmiType().isEmpty()) {
            throw new PayloadNotValidException("AmiType is required");
        }
        if (managedClusterDTO.getSupportedFunctionTypes() == null || managedClusterDTO.getSupportedFunctionTypes().isEmpty()) {
            throw new PayloadNotValidException("SupportedFunctionTypes is required");
        }
        if (managedClusterDTO.getCloudCredentialUid() == null || managedClusterDTO.getCloudCredentialUid().isEmpty()) {
            throw new PayloadNotValidException("CloudCredentialUid is required");
        }

        CloudCredential foundCredential = cloudCredentialRepository.findByUid(managedClusterDTO.getCloudCredentialUid());
        if (foundCredential == null) {
            throw new PayloadNotValidException("The cloud credential UID is not correct. Please check your Cloud Credential");
        }
    }

    public void validate(UnmanagedClusterDTO unmanagedClusterDTO) {

        if (unmanagedClusterDTO.getClusterName() == null || unmanagedClusterDTO.getClusterName().isEmpty()) {
            throw new PayloadNotValidException("Cluster Name is required");
        }
        if (unmanagedClusterDTO.getSupportedFunctionTypes() == null || unmanagedClusterDTO.getSupportedFunctionTypes().isEmpty()) {
            throw new PayloadNotValidException("SupportedFunctionTypes is required");
        }
        if (unmanagedClusterDTO.getApiServerEndpoint() == null || unmanagedClusterDTO.getApiServerEndpoint().isEmpty()) {
            throw new PayloadNotValidException("ApiServerEndpoint is required");
        }
        if (unmanagedClusterDTO.getCloudProvider() == null || unmanagedClusterDTO.getCloudProvider().toString().isEmpty()) {
            throw new PayloadNotValidException("CloudProvider is required");
        }
        if (unmanagedClusterDTO.getRegion() == null || unmanagedClusterDTO.getRegion().isEmpty()) {
            throw new PayloadNotValidException("Region is required");
        }
        if (unmanagedClusterDTO.getCloudCredentialUid() == null || unmanagedClusterDTO.getCloudCredentialUid().isEmpty()) {
            throw new PayloadNotValidException("CloudCredentialUid is required");
        }

        CloudCredential foundCredential = cloudCredentialRepository.findByUid(unmanagedClusterDTO.getCloudCredentialUid());
        if (foundCredential == null) {
            throw new PayloadNotValidException("The cloud credential UID is not correct. Please enter a valid cloud credential UID");
        }

    }

    public void validate(LocalClusterDTO localClusterDTO) {

        if (localClusterDTO.getClusterName() == null || localClusterDTO.getClusterName().isEmpty()) {
            throw new PayloadNotValidException("KubernetesCluster Name is required");
        }
        if (localClusterDTO.getSupportedFunctionTypes() == null || localClusterDTO.getSupportedFunctionTypes().isEmpty()) {
            throw new PayloadNotValidException("SupportedFunctionTypes is required");
        }
        if (localClusterDTO.getApiServerEndpoint() == null || localClusterDTO.getApiServerEndpoint().isEmpty()) {
            throw new PayloadNotValidException("ApiServerEndpoint is required");
        }
        if (localClusterDTO.getHostUrl() == null || localClusterDTO.getHostUrl().isEmpty()) {
            throw new PayloadNotValidException("HostName is required");
        }
        if (localClusterDTO.getKubernetesAccessTokenUid() == null || localClusterDTO.getKubernetesAccessTokenUid().isEmpty()) {
            throw new PayloadNotValidException("KubernetesAccessTokenUid is required");
        }
        AccessToken token = accessTokenRepository.findByUid(localClusterDTO.getKubernetesAccessTokenUid());
        if (token == null) {
            throw new PayloadNotValidException("The access token UID is not correct. Please enter a valid access token UID");
        }
    }


    }
